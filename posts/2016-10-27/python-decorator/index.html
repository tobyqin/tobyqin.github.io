<!DOCTYPE html><html lang="cn" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="详解Python的装饰器" /><meta property="og:locale" content="cn" /><meta name="description" content="Python 中的装饰器是你进入 Python 大门的一道坎，不管你跨不跨过去它都在那里。" /><meta property="og:description" content="Python 中的装饰器是你进入 Python 大门的一道坎，不管你跨不跨过去它都在那里。" /><link rel="canonical" href="https://tobyqin.cn/posts/2016-10-27/python-decorator/" /><meta property="og:url" content="https://tobyqin.cn/posts/2016-10-27/python-decorator/" /><meta property="og:site_name" content="Practice" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2016-10-27T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="详解Python的装饰器" /><meta name="twitter:site" content="@toby_qin" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2016-10-27T00:00:00+08:00","datePublished":"2016-10-27T00:00:00+08:00","description":"Python 中的装饰器是你进入 Python 大门的一道坎，不管你跨不跨过去它都在那里。","headline":"详解Python的装饰器","mainEntityOfPage":{"@type":"WebPage","@id":"https://tobyqin.cn/posts/2016-10-27/python-decorator/"},"url":"https://tobyqin.cn/posts/2016-10-27/python-decorator/"}</script><title>详解Python的装饰器 | Practice</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Practice"><meta name="application-name" content="Practice"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://image.tobyqin.cn/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Practice</a></div><div class="site-subtitle font-italic">makes perfect</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span></span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/notes/" class="nav-link"> <i class="fa-fw fas fa-book-open ml-xl-3 mr-xl-3 unloaded"></i> <span>NOTES</span> </a><li class="nav-item"> <a href="/md/" class="nav-link"> <i class="fa-fw fas fa-book-open ml-xl-3 mr-xl-3 unloaded"></i> <span>EDITOR</span> </a><li class="nav-item"> <a href="/hiring/" class="nav-link"> <i class="fa-fw fas fa-book-open ml-xl-3 mr-xl-3 unloaded"></i> <span>HIRING</span> </a><li class="nav-item"> <a href="/links/" class="nav-link"> <i class="fa-fw fas fa-book-open ml-xl-3 mr-xl-3 unloaded"></i> <span>LINKS</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT AUTHOR</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/tobyqin" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hello','tobyqin.cn'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a> <a href="https://www.linkedin.com/in/toby-qin-2684a630/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> </a> </span> <span>详解Python的装饰器</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="..."> </span> <span id="search-cancel" ></span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>详解Python的装饰器</h1><div class="post-meta text-muted"> <span> <em class="" data-ts="1477497600" data-df="DD/MM/YYYY" data-toggle="tooltip" data-placement="bottom"> 27/10/2016 </em> </span><div class="d-flex justify-content-between"> <span> <em> <a href="https://github.com/tobyqin">Toby Qin</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4239 "> <em>23 </em> </span></div></div></div><div class="post-content"><p>Python 中的装饰器是你进入 Python 大门的一道坎，不管你跨不跨过去它都在那里。</p><h2 id="为什么需要装饰器"><span class="mr-2">为什么需要装饰器</span><a href="#为什么需要装饰器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们假设你的程序实现了<code class="language-plaintext highlighter-rouge">say_hello()</code>和<code class="language-plaintext highlighter-rouge">say_goodbye()</code>两个函数。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">say_hello</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">"hello!"</span>

<span class="k">def</span> <span class="nf">say_goodbye</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">"hello!"</span>  <span class="c1"># bug here
</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">say_hello</span><span class="p">()</span>
    <span class="n">say_goodbye</span><span class="p">()</span>
</pre></table></code></div></div><p>但是在实际调用中，我们发现程序出错了，上面的代码打印了两个 hello。经过调试你发现是<code class="language-plaintext highlighter-rouge">say_goodbye()</code>出错了。老板要求调用每个方法前都要记录进入函数的时间和名称，比如这样：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>[DEBUG] 2016-10-27 11:11:11 - Enter say_hello()
Hello!
[DEBUG] 2016-10-27 11:11:11 - Enter say_goodbye()
Goodbye!
</pre></table></code></div></div><p>好，小 A 是个毕业生，他是这样实现的。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">say_hello</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">"[DEBUG]: enter say_hello()"</span>
    <span class="k">print</span> <span class="s">"hello!"</span>

<span class="k">def</span> <span class="nf">say_goodbye</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">"[DEBUG]: enter say_goodbye()"</span>
    <span class="k">print</span> <span class="s">"hello!"</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">say_hello</span><span class="p">()</span>
    <span class="n">say_goodbye</span><span class="p">()</span>
</pre></table></code></div></div><p>很 low 吧？ 嗯是的。小 B 工作有一段时间了，他告诉小 A 应该这样写。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">debug</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">inspect</span>
    <span class="n">caller_name</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">.</span><span class="n">stack</span><span class="p">()[</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">print</span> <span class="s">"[DEBUG]: enter {}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">caller_name</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">say_hello</span><span class="p">():</span>
    <span class="n">debug</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">"hello!"</span>

<span class="k">def</span> <span class="nf">say_goodbye</span><span class="p">():</span>
    <span class="n">debug</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">"goodbye!"</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">say_hello</span><span class="p">()</span>
    <span class="n">say_goodbye</span><span class="p">()</span>
</pre></table></code></div></div><p>是不是好一点？那当然，但是每个业务函数里都要调用一下<code class="language-plaintext highlighter-rouge">debug()</code>函数，是不是很难受？万一老板说 say 相关的函数不用 debug，do 相关的才需要呢？</p><p>那么装饰器这时候应该登场了。</p><blockquote><p>装饰器本质上是一个 Python 函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p></blockquote><p>概括的讲，装饰器的作用就是<strong>为已经存在的函数或对象添加额外的功能</strong>。</p><h2 id="怎么写一个装饰器"><span class="mr-2">怎么写一个装饰器</span><a href="#怎么写一个装饰器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在早些时候 (Python Version &lt; 2.4，2004 年以前)，为一个函数添加额外功能的写法是这样的。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">"[DEBUG]: enter {}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="k">def</span> <span class="nf">say_hello</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">"hello!"</span>

<span class="n">say_hello</span> <span class="o">=</span> <span class="n">debug</span><span class="p">(</span><span class="n">say_hello</span><span class="p">)</span>  <span class="c1"># 添加功能并保持原函数名不变
</span></pre></table></code></div></div><p>上面的 debug 函数其实已经是一个装饰器了，它对原函数做了包装并返回了另外一个函数，额外添加了一些功能。因为这样写实在不太优雅，在后面版本的 Python 中支持了@语法糖，下面代码等同于早期的写法。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">():</span>
        <span class="k">print</span> <span class="s">"[DEBUG]: enter {}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="o">@</span><span class="n">debug</span>
<span class="k">def</span> <span class="nf">say_hello</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">"hello!"</span>
</pre></table></code></div></div><p>这是最简单的装饰器，但是有一个问题，如果被装饰的函数需要传入参数，那么这个装饰器就坏了。因为返回的函数并不能接受参数，你可以指定装饰器函数<code class="language-plaintext highlighter-rouge">wrapper</code>接受和原函数一样的参数，比如：</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">something</span><span class="p">):</span>  <span class="c1"># 指定一毛一样的参数
</span>        <span class="k">print</span> <span class="s">"[DEBUG]: enter {}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">something</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>  <span class="c1"># 返回包装过函数
</span>
<span class="o">@</span><span class="n">debug</span>
<span class="k">def</span> <span class="nf">say</span><span class="p">(</span><span class="n">something</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">"hello {}!"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">something</span><span class="p">)</span>
</pre></table></code></div></div><p>这样你就解决了一个问题，但又多了 N 个问题。因为函数有千千万，你只管你自己的函数，别人的函数参数是什么样子，鬼知道？还好 Python 提供了可变参数<code class="language-plaintext highlighter-rouge">*args</code>和关键字参数<code class="language-plaintext highlighter-rouge">**kwargs</code>，有了这两个参数，装饰器就可以用于任意目标函数了。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">debug</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># 指定宇宙无敌参数
</span>        <span class="k">print</span> <span class="s">"[DEBUG]: enter {}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">'Prepare and say...'</span><span class="p">,</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>  <span class="c1"># 返回
</span>
<span class="o">@</span><span class="n">debug</span>
<span class="k">def</span> <span class="nf">say</span><span class="p">(</span><span class="n">something</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">"hello {}!"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">something</span><span class="p">)</span>
</pre></table></code></div></div><p>至此，你已完全掌握初级的装饰器写法。</p><h2 id="高级一点的装饰器"><span class="mr-2">高级一点的装饰器</span><a href="#高级一点的装饰器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>带参数的装饰器和类装饰器属于进阶的内容。在理解这些装饰器之前，最好对函数的闭包和装饰器的接口约定有一定了解。(参见 <a href="https://tobyqin.cn/posts/2016-10-22/python-closure/">https://tobyqin.cn/posts/2016-10-22/python-closure/</a>)</p><h3 id="带参数的装饰器"><span class="mr-2">带参数的装饰器</span><a href="#带参数的装饰器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>假设我们前文的装饰器需要完成的功能不仅仅是能在进入某个函数后打出 log 信息，而且还需指定 log 的级别，那么装饰器就会是这样的。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">logging</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">inner_wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">"[{level}]: enter function {func}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span>
                <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inner_wrapper</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="o">@</span><span class="n">logging</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s">'INFO'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">say</span><span class="p">(</span><span class="n">something</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">"say {}!"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">something</span><span class="p">)</span>

<span class="c1"># 如果没有使用@语法，等同于
# say = logging(level='INFO')(say)
</span>
<span class="o">@</span><span class="n">logging</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s">'DEBUG'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do</span><span class="p">(</span><span class="n">something</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">"do {}..."</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">something</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">say</span><span class="p">(</span><span class="s">'hello'</span><span class="p">)</span>
    <span class="n">do</span><span class="p">(</span><span class="s">"my work"</span><span class="p">)</span>
</pre></table></code></div></div><p>是不是有一些晕？你可以这么理解，当带参数的装饰器被打在某个函数上时，比如<code class="language-plaintext highlighter-rouge">@logging(level='DEBUG')</code>，它其实是一个函数，会马上被执行，只要这个它返回的结果是一个装饰器时，那就没问题。细细再体会一下。</p><h3 id="基于类实现的装饰器"><span class="mr-2">基于类实现的装饰器</span><a href="#基于类实现的装饰器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>装饰器函数其实是这样一个接口约束，它必须接受一个 callable 对象作为参数，然后返回一个 callable 对象。在 Python 中一般 callable 对象都是函数，但也有例外。只要某个对象重载了<code class="language-plaintext highlighter-rouge">__call__()</code>方法，那么这个对象就是 callable 的。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Test</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">'call me!'</span>

<span class="n">t</span> <span class="o">=</span> <span class="n">Test</span><span class="p">()</span>
<span class="n">t</span><span class="p">()</span>  <span class="c1"># call me
</span></pre></table></code></div></div><p>像<code class="language-plaintext highlighter-rouge">__call__</code>这样前后都带下划线的方法在 Python 中被称为内置方法，有时候也被称为魔法方法。重载这些魔法方法一般会改变对象的内部行为。上面这个例子就让一个类对象拥有了被调用的行为。</p><p>回到装饰器上的概念上来，装饰器要求接受一个 callable 对象，并返回一个 callable 对象（不太严谨，详见后文）。那么用类来实现也是也可以的。我们可以让类的构造函数<code class="language-plaintext highlighter-rouge">__init__()</code>接受一个函数，然后重载<code class="language-plaintext highlighter-rouge">__call__()</code>并返回一个函数，也可以达到装饰器函数的效果。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">logging</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">"[DEBUG]: enter function {func}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span>
            <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="o">@</span><span class="n">logging</span>
<span class="k">def</span> <span class="nf">say</span><span class="p">(</span><span class="n">something</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">"say {}!"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">something</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="带参数的类装饰器"><span class="mr-2">带参数的类装饰器</span><a href="#带参数的类装饰器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>如果需要通过类形式实现带参数的装饰器，那么会比前面的例子稍微复杂一点。那么在构造函数里接受的就不是一个函数，而是传入的参数。通过类把这些参数保存起来。然后在重载<code class="language-plaintext highlighter-rouge">__call__</code>方法是就需要接受一个函数并返回一个函数。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">logging</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s">'INFO'</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span> <span class="c1"># 接受函数
</span>        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">"[{level}]: enter function {func}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span>
                <span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">,</span>
                <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
            <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>  <span class="c1">#返回函数
</span>
<span class="o">@</span><span class="n">logging</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s">'INFO'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">say</span><span class="p">(</span><span class="n">something</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">"say {}!"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">something</span><span class="p">)</span>
</pre></table></code></div></div><h3 id="内置的装饰器"><span class="mr-2">内置的装饰器</span><a href="#内置的装饰器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>内置的装饰器和普通的装饰器原理是一样的，只不过返回的不是函数，而是类对象，所以更难理解一些。</p><h4 id="property"><span class="mr-2">@property</span><a href="#property" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>在了解这个装饰器前，你需要知道在不使用装饰器怎么写一个属性。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">getx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_x</span>

<span class="k">def</span> <span class="nf">setx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="bp">self</span><span class="p">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">value</span>

<span class="k">def</span> <span class="nf">delx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
   <span class="k">del</span> <span class="bp">self</span><span class="p">.</span><span class="n">_x</span>

<span class="c1"># create a property
</span><span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">getx</span><span class="p">,</span> <span class="n">setx</span><span class="p">,</span> <span class="n">delx</span><span class="p">,</span> <span class="s">"I am doc for x property"</span><span class="p">)</span>
</pre></table></code></div></div><p>以上就是一个 Python 属性的标准写法，其实和 Java 挺像的，但是太罗嗦。有了@语法糖，能达到一样的效果但看起来更简单。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="o">@</span><span class="nb">property</span>
<span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="p">...</span>

<span class="c1"># 等同于
</span>
<span class="k">def</span> <span class="nf">x</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="p">...</span>
<span class="n">x</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></table></code></div></div><p>属性有三个装饰器：<code class="language-plaintext highlighter-rouge">setter</code>, <code class="language-plaintext highlighter-rouge">getter</code>, <code class="language-plaintext highlighter-rouge">deleter</code> ，都是在<code class="language-plaintext highlighter-rouge">property()</code>的基础上做了一些封装，因为<code class="language-plaintext highlighter-rouge">setter</code>和<code class="language-plaintext highlighter-rouge">deleter</code>是<code class="language-plaintext highlighter-rouge">property()</code>的第二和第三个参数，不能直接套用@语法。<code class="language-plaintext highlighter-rouge">getter</code>装饰器和不带<code class="language-plaintext highlighter-rouge">getter</code>的属性装饰器效果是一样的，估计只是为了凑数，本身没有任何存在的意义。经过<code class="language-plaintext highlighter-rouge">@property</code>装饰过的函数返回的不再是一个函数，而是一个<code class="language-plaintext highlighter-rouge">property</code>对象。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="o">&gt;&gt;&gt;</span> <span class="nb">property</span><span class="p">()</span>
<span class="o">&lt;</span><span class="nb">property</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x10ff07940</span><span class="o">&gt;</span>
</pre></table></code></div></div><h4 id="staticmethodclassmethod"><span class="mr-2">@staticmethod，@classmethod</span><a href="#staticmethodclassmethod" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>有了<code class="language-plaintext highlighter-rouge">@property</code>装饰器的了解，这两个装饰器的原理是差不多的。<code class="language-plaintext highlighter-rouge">@staticmethod</code>返回的是一个<code class="language-plaintext highlighter-rouge">staticmethod</code>类对象，而<code class="language-plaintext highlighter-rouge">@classmethod</code>返回的是一个<code class="language-plaintext highlighter-rouge">classmethod</code>类对象。他们都是调用的是各自的<code class="language-plaintext highlighter-rouge">__init__()</code>构造函数。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">classmethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s">"""
    classmethod(function) -&gt; method
    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span> <span class="c1"># for @classmethod decorator
</span>        <span class="k">pass</span>
    <span class="c1"># ...
</span><span class="k">class</span> <span class="nc">staticmethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="s">"""
    staticmethod(function) -&gt; method
    """</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function</span><span class="p">):</span> <span class="c1"># for @staticmethod decorator
</span>        <span class="k">pass</span>
    <span class="c1"># ...
</span></pre></table></code></div></div><p>装饰器的@语法就等同调用了这两个类的构造函数。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
        <span class="k">pass</span>

    <span class="c1"># 等同于 bar = staticmethod(bar)
</span></pre></table></code></div></div><p>至此，我们上文提到的装饰器接口定义可以更加明确一些，装饰器必须接受一个 callable 对象，其实它并不关心你返回什么，可以是另外一个 callable 对象（大部分情况），也可以是其他类对象，比如 property。</p><h2 id="装饰器里的那些坑"><span class="mr-2">装饰器里的那些坑</span><a href="#装饰器里的那些坑" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>装饰器可以让你代码更加优雅，减少重复，但也不全是优点，也会带来一些问题。</p><h3 id="位置错误的代码"><span class="mr-2">位置错误的代码</span><a href="#位置错误的代码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>让我们直接看示例代码。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">html_tags</span><span class="p">(</span><span class="n">tag_name</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">'begin outer function.'</span>
    <span class="k">def</span> <span class="nf">wrapper_</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">"begin of inner wrapper function."</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">content</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">print</span> <span class="s">"&lt;{tag}&gt;{content}&lt;/{tag}&gt;"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="n">tag_name</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="n">content</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">'end of inner wrapper function.'</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">print</span> <span class="s">'end of outer function'</span>
    <span class="k">return</span> <span class="n">wrapper_</span>

<span class="o">@</span><span class="n">html_tags</span><span class="p">(</span><span class="s">'b'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'Toby'</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">'Hello {}!'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<span class="n">hello</span><span class="p">()</span>
<span class="n">hello</span><span class="p">()</span>
</pre></table></code></div></div><p>在装饰器中我在各个可能的位置都加上了 print 语句，用于记录被调用的情况。你知道他们最后打印出来的顺序吗？如果你心里没底，那么最好不要在装饰器函数之外添加逻辑功能，否则这个装饰器就不受你控制了。以下是输出结果：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>begin outer function.
end of outer function
begin of inner wrapper function.
end of inner wrapper function.
&lt;b&gt;Hello Toby!&lt;/b&gt;
&lt;b&gt;Hello Toby!&lt;/b&gt;
</pre></table></code></div></div><h3 id="错误的函数签名和文档"><span class="mr-2">错误的函数签名和文档</span><a href="#错误的函数签名和文档" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>装饰器装饰过的函数看上去名字没变，其实已经变了。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">logging</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""print log before a function."""</span>
        <span class="k">print</span> <span class="s">"[DEBUG] {}: enter {}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">(),</span> <span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="o">@</span><span class="n">logging</span>
<span class="k">def</span> <span class="nf">say</span><span class="p">(</span><span class="n">something</span><span class="p">):</span>
    <span class="s">"""say something"""</span>
    <span class="k">print</span> <span class="s">"say {}!"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">something</span><span class="p">)</span>

<span class="k">print</span> <span class="n">say</span><span class="p">.</span><span class="n">__name__</span>  <span class="c1"># wrapper
</span></pre></table></code></div></div><p>为什么会这样呢？只要你想想装饰器的语法糖@代替的东西就明白了。@等同于这样的写法。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">say</span> <span class="o">=</span> <span class="n">logging</span><span class="p">(</span><span class="n">say</span><span class="p">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">logging</code>其实返回的函数名字刚好是<code class="language-plaintext highlighter-rouge">wrapper</code>，那么上面的这个语句刚好就是把这个结果赋值给<code class="language-plaintext highlighter-rouge">say</code>，<code class="language-plaintext highlighter-rouge">say</code>的<code class="language-plaintext highlighter-rouge">__name__</code>自然也就是<code class="language-plaintext highlighter-rouge">wrapper</code>了，不仅仅是<code class="language-plaintext highlighter-rouge">name</code>，其他属性也都是来自<code class="language-plaintext highlighter-rouge">wrapper</code>，比如<code class="language-plaintext highlighter-rouge">doc</code>，<code class="language-plaintext highlighter-rouge">source</code>等等。</p><p>使用标准库里的<code class="language-plaintext highlighter-rouge">functools.wraps</code>，可以<strong>基本</strong>解决这个问题。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">wraps</span>

<span class="k">def</span> <span class="nf">logging</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="o">@</span><span class="n">wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""print log before a function."""</span>
        <span class="k">print</span> <span class="s">"[DEBUG] {}: enter {}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">(),</span> <span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="o">@</span><span class="n">logging</span>
<span class="k">def</span> <span class="nf">say</span><span class="p">(</span><span class="n">something</span><span class="p">):</span>
    <span class="s">"""say something"""</span>
    <span class="k">print</span> <span class="s">"say {}!"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">something</span><span class="p">)</span>

<span class="k">print</span> <span class="n">say</span><span class="p">.</span><span class="n">__name__</span>  <span class="c1"># say
</span><span class="k">print</span> <span class="n">say</span><span class="p">.</span><span class="n">__doc__</span> <span class="c1"># say something
</span></pre></table></code></div></div><p>看上去不错！主要问题解决了，但其实还不太完美。因为函数的签名和源码还是拿不到的。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">inspect</span>
<span class="k">print</span> <span class="n">inspect</span><span class="p">.</span><span class="n">getargspec</span><span class="p">(</span><span class="n">say</span><span class="p">)</span>  <span class="c1"># failed
</span><span class="k">print</span> <span class="n">inspect</span><span class="p">.</span><span class="n">getsource</span><span class="p">(</span><span class="n">say</span><span class="p">)</span>  <span class="c1"># failed
</span></pre></table></code></div></div><p>如果要彻底解决这个问题可以借用第三方包，比如<code class="language-plaintext highlighter-rouge">wrapt</code>。后文有介绍。</p><h3 id="不能装饰staticmethod-或者-classmethod"><span class="mr-2">不能装饰@staticmethod 或者 @classmethod</span><a href="#不能装饰staticmethod-或者-classmethod" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>当你想把装饰器用在一个静态方法或者类方法时，不好意思，报错了。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Car</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

    <span class="o">@</span><span class="n">logging</span>  <span class="c1"># 装饰实例方法，OK
</span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">"{} is running!"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="p">)</span>

    <span class="o">@</span><span class="n">logging</span>  <span class="c1"># 装饰静态方法，Failed
</span>    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">check_model_for</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Car</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">"The model of your car is {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">model</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">"{} is not a car!"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

<span class="s">"""
Traceback (most recent call last):
...
  File "example_4.py", line 10, in logging
    @wraps(func)
  File "C:\Python27\lib</span><span class="se">\f</span><span class="s">unctools.py", line 33, in update_wrapper
    setattr(wrapper, attr, getattr(wrapped, attr))
AttributeError: 'staticmethod' object has no attribute '__module__'
"""</span>
</pre></table></code></div></div><p>前面已经解释了<code class="language-plaintext highlighter-rouge">@staticmethod</code>这个装饰器，其实它返回的并不是一个 callable 对象，而是一个<code class="language-plaintext highlighter-rouge">staticmethod</code>对象，那么它是不符合装饰器要求的（比如传入一个 callable 对象），你自然不能在它之上再加别的装饰器。要解决这个问题很简单，只要把你的装饰器放在<code class="language-plaintext highlighter-rouge">@staticmethod</code>之前就好了，因为你的装饰器返回的还是一个正常的函数，然后再加上一个<code class="language-plaintext highlighter-rouge">@staticmethod</code>是不会出问题的。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Car</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">model</span>

    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="o">@</span><span class="n">logging</span>  <span class="c1"># 在@staticmethod之前装饰，OK
</span>    <span class="k">def</span> <span class="nf">check_model_for</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></table></code></div></div><h2 id="如何优化你的装饰器"><span class="mr-2">如何优化你的装饰器</span><a href="#如何优化你的装饰器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>嵌套的装饰函数不太直观，我们可以使用第三方包类改进这样的情况，让装饰器函数可读性更好。</p><h3 id="decoratorpy"><span class="mr-2">decorator.py</span><a href="#decoratorpy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="http://pythonhosted.org/decorator/documentation.html">decorator.py</a> 是一个非常简单的装饰器加强包。你可以很直观的先定义包装函数<code class="language-plaintext highlighter-rouge">wrapper()</code>，再使用<code class="language-plaintext highlighter-rouge">decorate(func, wrapper)</code>方法就可以完成一个装饰器。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">decorator</span> <span class="kn">import</span> <span class="n">decorate</span>

<span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="s">"""print log before a function."""</span>
    <span class="k">print</span> <span class="s">"[DEBUG] {}: enter {}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">(),</span> <span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">logging</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">decorate</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">wrapper</span><span class="p">)</span>  <span class="c1"># 用wrapper装饰func
</span></pre></table></code></div></div><p>你也可以使用它自带的<code class="language-plaintext highlighter-rouge">@decorator</code>装饰器来完成你的装饰器。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kn">from</span> <span class="nn">decorator</span> <span class="kn">import</span> <span class="n">decorator</span>

<span class="o">@</span><span class="n">decorator</span>
<span class="k">def</span> <span class="nf">logging</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">print</span> <span class="s">"[DEBUG] {}: enter {}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">(),</span> <span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">decorator.py</code>实现的装饰器能完整保留原函数的<code class="language-plaintext highlighter-rouge">name</code>，<code class="language-plaintext highlighter-rouge">doc</code>和<code class="language-plaintext highlighter-rouge">args</code>，唯一有问题的就是<code class="language-plaintext highlighter-rouge">inspect.getsource(func)</code>返回的还是装饰器的源代码，你需要改成<code class="language-plaintext highlighter-rouge">inspect.getsource(func.__wrapped__)</code>。</p><h3 id="wrapt"><span class="mr-2">wrapt</span><a href="#wrapt" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="http://wrapt.readthedocs.io/en/latest/quick-start.html">wrapt</a>是一个功能非常完善的包，用于实现各种你想到或者你没想到的装饰器。使用 wrapt 实现的装饰器你不需要担心之前 inspect 中遇到的所有问题，因为它都帮你处理了，甚至<code class="language-plaintext highlighter-rouge">inspect.getsource(func)</code>也准确无误。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">wrapt</span>

<span class="c1"># without argument in decorator
</span><span class="o">@</span><span class="n">wrapt</span><span class="p">.</span><span class="n">decorator</span>
<span class="k">def</span> <span class="nf">logging</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>  <span class="c1"># instance is must
</span>    <span class="k">print</span> <span class="s">"[DEBUG]: enter {}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">wrapped</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="o">@</span><span class="n">logging</span>
<span class="k">def</span> <span class="nf">say</span><span class="p">(</span><span class="n">something</span><span class="p">):</span> <span class="k">pass</span>
</pre></table></code></div></div><p>使用 wrapt 你只需要定义一个装饰器函数，但是函数签名是固定的，必须是<code class="language-plaintext highlighter-rouge">(wrapped, instance, args, kwargs)</code>，注意第二个参数<code class="language-plaintext highlighter-rouge">instance</code>是必须的，就算你不用它。当装饰器装饰在不同位置时它将得到不同的值，比如装饰在类实例方法时你可以拿到这个类实例。根据<code class="language-plaintext highlighter-rouge">instance</code>的值你能够更加灵活的调整你的装饰器。另外，<code class="language-plaintext highlighter-rouge">args</code>和<code class="language-plaintext highlighter-rouge">kwargs</code>也是固定的，注意前面<strong>没有星号</strong>。在装饰器内部调用原函数时才带星号。</p><p>如果你需要使用 wrapt 写一个带参数的装饰器，可以这样写。</p><div class="language-python highlighter-rouge"><div class="code-header"> <span data-label-text="Python"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">logging</span><span class="p">(</span><span class="n">level</span><span class="p">):</span>
    <span class="o">@</span><span class="n">wrapt</span><span class="p">.</span><span class="n">decorator</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">"[{}]: enter {}()"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">wrapped</span><span class="p">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="o">@</span><span class="n">logging</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s">"INFO"</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">do</span><span class="p">(</span><span class="n">work</span><span class="p">):</span> <span class="k">pass</span>
</pre></table></code></div></div><p>关于 wrapt 的使用，建议查阅官方文档，在此不在赘述。</p><ul><li>http://wrapt.readthedocs.io/en/latest/quick-start.html</ul><h2 id="小结"><span class="mr-2">小结</span><a href="#小结" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Python 的装饰器和 Java 的注解（Annotation）并不是同一回事，和 C#中的特性（Attribute）也不一样，完全是两个概念。</p><p>装饰器的理念是对原函数、对象的加强，相当于重新封装，所以一般装饰器函数都被命名为<code class="language-plaintext highlighter-rouge">wrapper()</code>，意义在于包装。函数只有在被调用时才会发挥其作用。比如<code class="language-plaintext highlighter-rouge">@logging</code>装饰器可以在函数执行时额外输出日志，<code class="language-plaintext highlighter-rouge">@cache</code>装饰过的函数可以缓存计算结果等等。</p><p>而注解和特性则是对目标函数或对象添加一些属性，相当于将其分类。这些属性可以通过反射拿到，在程序运行时对不同的特性函数或对象加以干预。比如带有<code class="language-plaintext highlighter-rouge">Setup</code>的函数就当成准备步骤执行，或者找到所有带有<code class="language-plaintext highlighter-rouge">TestMethod</code>的函数依次执行等等。</p><p>至此我所了解的装饰器已经讲完，但是还有一些内容没有提到，比如装饰类的装饰器。有机会再补充。谢谢观看。</p><blockquote><p>本文源码 https://github.com/tobyqin/python_decorator</p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/tech/'>Tech</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/python/" class="post-tag no-text-decoration" >python</a> <a href="/tags/python-decorator/" class="post-tag no-text-decoration" >python decorator</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"></div><div class="share-wrapper"> <span class="share-label text-muted mr-1"></span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=详解Python的装饰器 - Practice&url=https%3A%2F%2Ftobyqin.cn%2Fposts%2F2016-10-27%2Fpython-decorator%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=详解Python的装饰器 - Practice&u=https%3A%2F%2Ftobyqin.cn%2Fposts%2F2016-10-27%2Fpython-decorator%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Ftobyqin.cn%2Fposts%2F2016-10-27%2Fpython-decorator%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="" data-title-succeed=""> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading"></div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/2023-01-28/devops-survey-2022/">软件研发体验调查报告 2022</a><li><a href="/posts/2022-12-28/goodbye-2022/">2022年，再见</a><li><a href="/posts/2019-06-25/various-schemes-for-forwarding-short-messages/">转发短信的各种方案</a><li><a href="/posts/2022-09-04/delegating/">如何有效授权</a><li><a href="/posts/2022-07-26/eat-the-frog/">吃掉那只青蛙</a></ul></div><div id="access-tags"><div class="panel-heading"></div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/tips/">tips</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/book/">book</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/life/">Life</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/flask/">flask</a> <a class="post-tag" href="/tags/python/">Python</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2"></div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip></h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/2016-10-30/python-decorator-more/"><div class="card-body"> <em class="small" data-ts="1477756800" data-df="DD/MM/YYYY" > 30/10/2016 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Python装饰器的另类用法</h3><div class="text-muted small"><p> 之前有比较系统介绍过 Python 的装饰器（请查阅《详解 Python 装饰器》），本文算是一个补充。今天我们一起探讨一下装饰器的另类用法。 语法回顾 开始之前我们再将 Python 装饰器的语法回顾一下。 1 2 3 @decorate def f(...): pass 等同于: 1 2 3 4 def f(...): pass f = decorate...</p></div></div></a></div><div class="card"> <a href="/posts/2016-10-18/reverse-by-word-in-python-en/"><div class="card-body"> <em class="small" data-ts="1476783960" data-df="DD/MM/YYYY" > 18/10/2016 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Reverse string by word with Python</h3><div class="text-muted small"><p> Reverse string by word is a very popular interview question. In python you can solve it easily with code like below. def reverse_string_by_word(s): lst = s.split() # split by blank space by...</p></div></div></a></div><div class="card"> <a href="/posts/2016-10-18/reverse-by-word-in-python/"><div class="card-body"> <em class="small" data-ts="1476783960" data-df="DD/MM/YYYY" > 18/10/2016 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Python中的反转字符串问题</h3><div class="text-muted small"><p> 按单词反转字符串是一道很常见的面试题。在 Python 中实现起来非常简单。 def reverse_string_by_word(s): lst = s.split() # split by blank space by default return &#39; &#39;.join(lst[::-1]) s = &#39;Power of Love&#39; print reverse_str...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/2016-10-23/python-closure/" class="btn btn-outline-primary" prompt=""><p>说说Python中的闭包 - Closure</p></a> <a href="/posts/2016-10-30/python-decorator-more/" class="btn btn-outline-primary" prompt=""><p>Python装饰器的另类用法</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "tobyqin/tobyqin.github.io", "data-repo-id": "R_kgDOHs0WtQ", "data-category": "Comments", "data-category-id": "DIC_kwDOHs0Wtc4CQYoq", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading"></div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/tips/">tips</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/book/">book</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/life/">Life</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/flask/">flask</a> <a class="post-tag" href="/tags/python/">Python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/tobyqin">Toby Qin</a>.</p></div><div class="footer-right"><p class="mb-0">Using the <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> theme <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a>.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5"></p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/cn.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-QDMM6HFTDF"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-QDMM6HFTDF'); }); </script>
