<!DOCTYPE html><html lang="cn" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Docker一篇通" /><meta property="og:locale" content="cn" /><meta name="description" content="Docker 作为当今最流行的容器技术，我们还是需要紧跟时代努力学习，避免被公司优化掉。本文以轻松愉快的方式介绍了我对容器的认识，需要深入的同学建议多多查阅官方文档。" /><meta property="og:description" content="Docker 作为当今最流行的容器技术，我们还是需要紧跟时代努力学习，避免被公司优化掉。本文以轻松愉快的方式介绍了我对容器的认识，需要深入的同学建议多多查阅官方文档。" /><link rel="canonical" href="https://tobyqin.cn/posts/2019-04-20/docker-in-one-day/" /><meta property="og:url" content="https://tobyqin.cn/posts/2019-04-20/docker-in-one-day/" /><meta property="og:site_name" content="Practice" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-04-20T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Docker一篇通" /><meta name="twitter:site" content="@toby_qin" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-23T21:54:41+08:00","datePublished":"2019-04-20T00:00:00+08:00","description":"Docker 作为当今最流行的容器技术，我们还是需要紧跟时代努力学习，避免被公司优化掉。本文以轻松愉快的方式介绍了我对容器的认识，需要深入的同学建议多多查阅官方文档。","headline":"Docker一篇通","mainEntityOfPage":{"@type":"WebPage","@id":"https://tobyqin.cn/posts/2019-04-20/docker-in-one-day/"},"url":"https://tobyqin.cn/posts/2019-04-20/docker-in-one-day/"}</script><title>Docker一篇通 | Practice</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Practice"><meta name="application-name" content="Practice"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://image.tobyqin.cn/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title"> <a href="/">Practice</a></div><div class="site-subtitle font-italic">makes perfect</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span></span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/notes/" class="nav-link"> <i class="fa-fw fas fa-book-open ml-xl-3 mr-xl-3 unloaded"></i> <span>NOTES</span> </a><li class="nav-item"> <a href="/md/" class="nav-link"> <i class="fa-fw fas fa-book-open ml-xl-3 mr-xl-3 unloaded"></i> <span>EDITOR</span> </a><li class="nav-item"> <a href="/hiring/" class="nav-link"> <i class="fa-fw fas fa-book-open ml-xl-3 mr-xl-3 unloaded"></i> <span>HIRING</span> </a><li class="nav-item"> <a href="/links/" class="nav-link"> <i class="fa-fw fas fa-book-open ml-xl-3 mr-xl-3 unloaded"></i> <span>LINKS</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT AUTHOR</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/tobyqin" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hello','tobyqin.cn'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a> <a href="https://www.linkedin.com/in/toby-qin-2684a630/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> </a> </span> <span>Docker一篇通</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="..."> </span> <span id="search-cancel" ></span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>Docker一篇通</h1><div class="post-meta text-muted"> <span> <em class="" data-ts="1555689600" data-df="DD/MM/YYYY" data-toggle="tooltip" data-placement="bottom"> 20/04/2019 </em> </span> <span> <em class="" data-ts="1658584481" data-df="DD/MM/YYYY" data-toggle="tooltip" data-placement="bottom"> 23/07/2022 </em> </span><div class="d-flex justify-content-between"> <span> <em> <a href="https://github.com/tobyqin">Toby Qin</a> </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4363 "> <em>24 </em> </span></div></div></div><div class="post-content"><p>Docker 作为当今最流行的容器技术，我们还是需要紧跟时代努力学习，避免被公司优化掉。本文以轻松愉快的方式介绍了我对容器的认识，需要深入的同学建议多多查阅<a href="https://docs.docker.com/engine/docker-overview/">官方文档</a>。</p><h2 id="为啥要-docker"><span class="mr-2">为啥要 Docker</span><a href="#为啥要-docker" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>千言万语不如一张图：</p><p><a href="https://image.tobyqin.cn/image-20190420141039942.png" class="popup img-link "><img data-src="https://image.tobyqin.cn/image-20190420141039942.png" alt="image-20190420141039942" class="lazyload" data-proofer-ignore></a></p><p>来源： <a href="https://www.docker.com/why-docker">https://www.docker.com/why-docker</a></p><p><strong>简单总结：</strong></p><ol><li>更少的部署时间，更高的交付效率 balabala，反正很厉害<li>老板花更少的资源，做更多的事<li>员工花更少的时间，做更多的事（加量不加价？）</ol><p>总之，Docker 可以让你和你的企业变得很牛很潮，甚于内裤外穿。</p><h2 id="啥是-docker"><span class="mr-2">啥是 Docker</span><a href="#啥是-docker" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>再来一张图：</p><p><a href="https://image.tobyqin.cn/image-20190420141741582.png" class="popup img-link "><img data-src="https://image.tobyqin.cn/image-20190420141741582.png" alt="image-20190420141741582" class="lazyload" data-proofer-ignore></a></p><p>来源： <a href="https://www.docker.com/resources/what-container">https://www.docker.com/resources/what-container</a></p><p>简单总结：</p><ol><li>Docker 是容器技术的一种实现，是当下最流行的（不代表以后还是它）<li>容器相对于虚拟机更轻量，但是能实现和虚拟机几乎一样的功能<li>虚拟机需要上 G 的磁盘空间外加和真实环境等效的 CPU，内存<li>容器只需要运行写入的磁盘空间（MB 级），能使用宿主机全部 CPU，内存</ol><p>打通俗一点的比分，独立的物理机是别墅，花园车库都是你的；虚拟机是楼盘卖的各种公寓，有独立的客厅卧室；容器是酒店里的房间，大部分资源都是公用的。</p><p>那为啥我不住别墅而住酒店呢？别墅不仅贵还要养管家，高档的酒店不见得比别墅和公寓差，但成本和管理效率高多了。</p><h2 id="怎么实现容器化"><span class="mr-2">怎么实现容器化</span><a href="#怎么实现容器化" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>我们可以把容器化流程一般化，例如作为软件发布方，流程大抵如此：</p><p><a href="https://image.tobyqin.cn/image-20190420151830272.png" class="popup img-link "><img data-src="https://image.tobyqin.cn/image-20190420151830272.png" alt="image-20190420151830272" class="lazyload" data-proofer-ignore></a></p><p>所谓基础镜像，你可以简单理解成操作系统。发布方需要把自己的软件和基础镜像打包后推送到仓库，就算容器化了。</p><p>注意，你要打包的不光是软件本身，还有各种配置过程，比如修改文件，修改权限，打开端口等等。</p><p>关于 Docker 镜像，我们可以看作千层饼，基础镜像是最下面一层，每添加一个功能（命令）就往上叠一层，看官方这个图：</p><p><a href="https://image.tobyqin.cn/2019-04/container-layers.jpg" class="popup img-link "><img data-src="https://image.tobyqin.cn/2019-04/container-layers.jpg" alt="Layers of a container based on the Ubuntu image" class="lazyload" data-proofer-ignore></a></p><p>基础层是 Ubuntu，上面的 4 层分别代表了加了 4 次功能，比如：</p><ol><li>Add file1<li>Install app1<li>Install app2<li>Change permission</ol><p>每一次运行命令都会生成一个层（Layer），每个层都是可以复用的。比如在任意层打上标签后发布，或者在下次制作镜像时加以利用（缓存加速）：</p><ol><li>Add file1 （秒完成）<li>Install app1 （秒完成）<li>Install app3 （新的 Layer）<li>Change permission （新的 Layer，上一步的 Layer 不一样）</ol><p>打包出来的镜像层是只读的，当镜像被运行后就会生成容器，每个容器都只是对镜像附加了一个可写层，所以资源利用率很高。</p><p>了解完生产方的流程后，我们来看一下消费方的流程：</p><p><a href="https://image.tobyqin.cn/image-20190420155230888.png" class="popup img-link "><img data-src="https://image.tobyqin.cn/image-20190420155230888.png" alt="image-20190420155230888" class="lazyload" data-proofer-ignore></a></p><p>作为消费方，可以用来去自如，为所欲为来描述容器化后的世界：</p><ol><li>我想要啥就去仓库 Pull 一下<li>运行容器，不必担心配置繁琐，环境差异这种烦心事<li>这镜像功能不错 - 那就让它跑着<li>这镜像是个乐色 - 分分钟删了它</ol><p>有了容器，开发的锅更难甩掉了，因为你是容器的爹，也是容器的妈。测试运维找上门，你再也不敢说在我这明明是好的啊。</p><h2 id="容器化的限制"><span class="mr-2">容器化的限制</span><a href="#容器化的限制" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>容器化的实现源于 Linux 系统本身的一种特性，叫<a href="https://en.wikipedia.org/wiki/OS-level_virtualisation">系统级虚拟化</a>（OS-level virtualisation）。早在 10 多年前在 Google 已经广泛应用，对，Google 那个糟老头坏的很，用了那么久都不跟我们说容器真香。等 Docker 火了以后它才说光 Docker 不够，你们还需要 Kubernets。</p><p><a href="https://image.tobyqin.cn/docker fun.jpeg" class="popup img-link "><img data-src="https://image.tobyqin.cn/docker fun.jpeg" alt="docker fun" class="lazyload" data-proofer-ignore></a></p><p>这张图经常出现在我们视线，为啥鲸鱼和企鹅还有老鼠在一起啊？鲸鱼代表着 Docker，企鹅代表着 Linux，老鼠代表着 Go 语言。Docker 运行的基础是 Linux，它是由 Go 语言编写的，哦原来 Docker 和它爹它妈在聚餐呢。</p><p>既然容器化原理离不开 Linux 特性，那么容器化的限制也显而易见：</p><ol><li>你的应用必须能跑在 Linux 上<li>你的应用应该是无状态的 - 允许随起随停</ol><p>举例说明，适合容器化的应用：</p><ul><li>前端服务，微服务，无状态任务</ul><p>不合适容器化的应用：</p><ul><li>数据库，数据库，数据库</ul><p>为啥数据库不适合容器化啊？第一，数据库是有状态的；第二，数据库不是想起就起想停就停的，数据安全大过天；第三第四第五网上写了一堆展开可以另写一篇。</p><h3 id="最佳实践"><span class="mr-2">最佳实践</span><a href="#最佳实践" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>容器化还有一些最佳实践：</p><ol><li>一个容器只运行一个应用<li>使用镜像来交付应用，不要直接部署<li>分层构建容器，尽可能减少层的数量<li>不要把本地运行的容器转成镜像<li>不要将数据存储在容器中</ol><h3 id="windows-容器"><span class="mr-2">Windows 容器</span><a href="#windows-容器" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>你可能听过<a href="https://www.microsoft.com/zh-cn/cloud-platform/containers">Windows 容器</a>，是有那么一回事，但是当前还不是很成熟，勇敢你的可以尝试，但你的老板大概是不会让它跑在生产环境的。据说携程已经将 Windows 容器化应用到生产了，牛 Pi（破音）！</p><h2 id="容器的优缺点"><span class="mr-2">容器的优缺点</span><a href="#容器的优缺点" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>优点显而易见，随便列几个：</p><ol><li>比 VM 小，比 VM 快，比 VM 便宜<li>更容易发布和维护，有效避免 DEV，QA，OPS 的撕逼<li>社区非常活跃，国外有谷歌微软亚马逊，国内有 BAT 做先驱</ol><p>那么缺点呢？并不是太多，不信你到网上找找看，大多是为赋新词强说愁，简单列举：</p><ol><li>平台限制，目前只支持 Unix/Linux 应用，只支持 64 位系统<li>相对于直接部署应用，性能会差一些<li>学习和迁移成本，取决于现有架构和资源<li>Docker 公司决策有点迷，很多言论说它要挂了</ol><p>理论讲完了，我们进入实操环节。</p><h2 id="安装-docker"><span class="mr-2">安装 Docker</span><a href="#安装-docker" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>现在 Docker 的安装非常傻瓜，只要从<a href="https://download.docker.com/">官网下载</a>对应平台的安装包点击几下就可以安装完成。你需要知道：</p><ol><li>Windows 用户需要开启<a href="https://docs.docker.com/docker-for-windows/troubleshoot/#virtualization-must-be-enabled">CPU 虚拟化</a>，配置 4G 内存以上，Windows 10 / 64 位系统<li>早期版本的 Windows 可以考虑使用<a href="https://docs.docker.com/toolbox/overview/">Docker Toolbox</a>或通过 Linux 虚拟机来安装<li>MacOSX 用户建议<a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac">下载 Docker Desktop</a>后安装，用 Brew 会更麻烦<li>Linux 用户最简单最野生，用各种包管理器就可以装，例如：</ol><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>yum <span class="nb">install </span>docker     <span class="c"># centos / redhat</span>
apt-get <span class="nb">install </span>docker <span class="c"># ubuntu</span>
</pre></table></code></div></div><p>坑：在 Windows 下，Docker 和 Genymotion 是有冲突的，一个要开 CPU 虚拟化，一个要关 CPU 虚拟化，二者势不两立，目前没有好的解决办法。</p><p>我们装的 Docker 都是 CE（Community Edition）版，另外 Docker 还提供了企业版。</p><div class="table-wrapper"><table><thead><tr><th style="text-align: left">Capabilities<th style="text-align: center">Docker Engine - Community<th style="text-align: center">Docker Engine - Enterprise<th style="text-align: center">Docker Enterprise<tbody><tr><td style="text-align: left">Container engine and built in orchestration, networking, security<td style="text-align: center">Yes<td style="text-align: center">Yes<td style="text-align: center">Yes<tr><td style="text-align: left">Certified infrastructure, plugins and ISV containers<td style="text-align: center"> <td style="text-align: center">Yes<td style="text-align: center">Yes<tr><td style="text-align: left">Image management<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center">Yes<tr><td style="text-align: left">Container app management<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center">Yes<tr><td style="text-align: left">Image security scanning<td style="text-align: center"> <td style="text-align: center"> <td style="text-align: center">Yes</table></div><h2 id="启动-docker"><span class="mr-2">启动 Docker</span><a href="#启动-docker" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>在 Windows / MacOSX 中，双击小鲸鱼就可以启动 Docker，启动成功后在通知区域就可以看到 Docker 的图标。</p><p>坑：在 Windows / MacOSX 中居然真的只能通过图形来重启或者停止 Docker 服务？！</p><p>在 Linux 中需要使用命令行来管理 Docker 服务，以 CentOS 7 为例。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>systemctl start docker
systemctl stop docker
systemctl <span class="nb">enable </span>docker <span class="c"># auto start when boot</span>
</pre></table></code></div></div><p>我们平时说的 Docker 一般是指 Docker Engine，前面提到的安装启动 Docker 指的都是 Docker Engine，这个 Engine 提供了一系列功能：</p><ol><li>管理镜像比如：拉取镜像，打包镜像，推送镜像<li>管理容器比如：运行容器，停止容器，诊断容器</ol><p>如果 Docker Engine 已经启动成功，在命令行（Windows 建议 PowerShell，MacOSX，Linux 建议 Bash）中就可以通过下面两个命令检查其运行状态。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>docker version
docker info
</pre></table></code></div></div><p>反之，如果 Docker Engine 没启动，那么就会有类似的错误。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>$ docker info
Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?
</pre></table></code></div></div><h2 id="docker-常用命令"><span class="mr-2">Docker 常用命令</span><a href="#docker-常用命令" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Docker 大部分操作都是通过命令行来完成的，对你还记得 Windows 和 MacOSX 的那个图像客户端，他们可以干什么？简单说他们除了用来启动和退出 Docker 外，还可以用来配置仓库源和网络代理地址，别的功能你就忘了吧。</p><p>还有，在中华大地，使用 Docker 前最好还是先<a href="https://yeasy.gitbooks.io/docker_practice/install/mirror.html">配置国内的源</a>，不然镜像会拉的很慢，便秘的感觉。</p><p>万事俱备，我们来一个 Docker Hello World：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nv">$ </span>docker run hello-world
Unable to find image <span class="s1">'hello-world:latest'</span> locally
latest: Pulling from library/hello-world
1b930d010525: Pull <span class="nb">complete
</span>Digest: sha256:92695bc579f31df7a63da6922075d0666e565ceccad16b59c3374d2cf4e8e50e
Status: Downloaded newer image <span class="k">for </span>hello-world:latest

Hello from Docker!
</pre></table></code></div></div><p>运行完这个命令，以后出去面试你就可以跟面试官说自己精通 Docker 和容器化技术了。</p><p>面试官再追问，你就说 Docker 命令太多了，我一般都是通过<code class="language-plaintext highlighter-rouge">docker --help</code> 查阅的。当然啦，咱也不水的，Docker 命令我说起来也是一套一套的，不信你往下看。</p><p>再说说这个 Hello World，你发现没有，作为消费方，其实你只要一个<code class="language-plaintext highlighter-rouge">docker run &lt;image&gt;</code> 命令就够了，Docker 足够聪明，如果这个<code class="language-plaintext highlighter-rouge">&lt;image&gt;</code> 不存在，那么它就会仓库里找，找到了就自动 pull，然后运行起来。</p><p>回到工作中，如果开发同学做完了一个需求，是不是告诉你这个<code class="language-plaintext highlighter-rouge">run</code>命令的具体参数就可以测试和发布了呢？（基本）是的！天啊，开发同学太厉害了，他变强了，也变秃了。</p><p><a href="https://image.tobyqin.cn/strong.jpg" class="popup img-link "><img data-src="https://image.tobyqin.cn/strong.jpg" alt="image" class="lazyload" data-proofer-ignore></a></p><p>聪明的你可能想到了，在社会人维护的 Docker 仓库里，其实包含了很多打包好的软件镜像，你只要<code class="language-plaintext highlighter-rouge">docker run</code>就行，比如 jenkins，sonarqube，redis，kafka，你能想到的全都有。天啊，原来用 Docker 整一个玩耍的环境那么简单！</p><h3 id="命令速记"><span class="mr-2">命令速记</span><a href="#命令速记" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>也许你知道一些 Docker 命令，比如：</p><ul><li>docker run<li>docker images<li>docker ps<li>docker rename<li>docker rm / rmi</ul><p>但是我真的建议你忘记它们，换一种方式去使用和记忆 Docker 命令。当你敲完<code class="language-plaintext highlighter-rouge">docker --help</code> 之后，出来的信息大概是这样的：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre>$ docker --help

Usage:	docker [OPTIONS] COMMAND

A self-sufficient runtime for containers

Options:
      ...

Management Commands:
  builder     Manage builds
  checkpoint  Manage checkpoints
  config      Manage Docker configs
  container   Manage containers
  image       Manage images
  network     Manage networks
  node        Manage Swarm nodes
  plugin      Manage plugins
  secret      Manage Docker secrets
  service     Manage services
  stack       Manage Docker stacks
  swarm       Manage Swarm
  system      Manage Docker
  trust       Manage trust on Docker images
  volume      Manage volumes

Commands:
  ...
</pre></table></code></div></div><p>不重要的部分我都省略了，在当前和未来版本的 Docker 中，官方都极力推荐我们通过管理命令去执行 Docker 命令。比如说：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker image ls
</pre></table></code></div></div><p>而不是：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker images
</pre></table></code></div></div><p>推荐使用：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker container ls
</pre></table></code></div></div><p>而不是：</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>docker ps
</pre></table></code></div></div><p>虽然<code class="language-plaintext highlighter-rouge">docker ps</code> / <code class="language-plaintext highlighter-rouge">docker exec</code> 等等命令更简洁，但是也更混乱，不便记忆。你有时候甚至不确定自己操作的是容器还是镜像或者是别的对象？</p><p>让我们再仔细对比一下管理命令和简化版命令：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c"># via management command</span>
docker image <span class="nb">ls
</span>docker image <span class="nb">rm
</span>docker image <span class="nb">history

</span>docker container ps
docker container rename
docker container <span class="nb">rm</span>

<span class="c"># via docker command</span>
docker images
docker rmi
docker <span class="nb">history

</span>docker ps
docker rename
docker <span class="nb">rm</span>
</pre></table></code></div></div><p>所以在你理解 Docker 能做的事情后，再通过管理命令去实践你就会事半功倍。我做了一个思维导图，列出了常见的操作。</p><p><a href="https://image.tobyqin.cn/image-20190420185522119.png" class="popup img-link "><img data-src="https://image.tobyqin.cn/image-20190420185522119.png" alt="image-20190420185522119" class="lazyload" data-proofer-ignore></a></p><p>在敲命令时你要时刻记住自己要做什么，不要迷路：</p><ol><li>需要配置网络，那就<code class="language-plaintext highlighter-rouge">docker network xxx</code><li>需要配置存储，那就<code class="language-plaintext highlighter-rouge">docker volume xxx</code><li>需要管理镜像，那就<code class="language-plaintext highlighter-rouge">docker image xxx</code><li>需要管理容器，那就<code class="language-plaintext highlighter-rouge">docker container xxx</code></ol><p>是不是超级简单？</p><h3 id="portainer"><span class="mr-2">portainer</span><a href="#portainer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><a href="https://www.portainer.io/">portainer</a> 是一个浏览器界面的图形化 Docker 管理工具，它实现了几乎所有的 Docker Engine 操作，你只要两条命令就可以让它运行在你的机器上。</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>$ docker volume create portainer_data
$ docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer
</pre></table></code></div></div><p><a href="https://image.tobyqin.cn/image-20190420231352125.png" class="popup img-link "><img data-src="https://image.tobyqin.cn/image-20190420231352125.png" alt="image-20190420231352125" class="lazyload" data-proofer-ignore></a></p><p>有了它，你就可以忘掉上面的命令，前提是你先通过面试。</p><h2 id="dockerfile"><span class="mr-2">Dockerfile</span><a href="#dockerfile" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>要制作容器镜像，你需要一个详细的步骤，这个实施过程记录下来就是 Dockerfile。我们来看一个例子：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>FROM ubuntu:18.04
COPY <span class="nb">.</span> /app
RUN make /app
CMD python /app/app.py
</pre></table></code></div></div><p>其实 Dockerfile 很简单易懂，无非就是第一做什么第二做什么，自己写几遍就记住了。在 Dockerfile 中可以用的命令并不是特别多。</p><div class="table-wrapper"><table><thead><tr><th>关键字<th>解释<tbody><tr><td>FROM<td>选择基础镜像版本，例如：<code class="language-plaintext highlighter-rouge">FROM ubuntu:18.04</code><tr><td>LABEL<td>给镜像添加标签，例如：<code class="language-plaintext highlighter-rouge">LABEL version="0.0.1-beta"</code><tr><td>WORKDIR<td>指定工作目录（会自动创建），例如：<code class="language-plaintext highlighter-rouge">WORKDIR /target</code><tr><td>ADD / COPY<td>复制文件，ADD 会自动解压，例如：<code class="language-plaintext highlighter-rouge">COPY . /target</code><tr><td>RUN<td>运行命令，例如：<code class="language-plaintext highlighter-rouge">RUN apt-get update -y</code><tr><td>ENV<td>设置环境变量，例如：<code class="language-plaintext highlighter-rouge">ENV PG_VERSION 9.3.4</code><tr><td>USER<td>不使用 root 来运行容器，例如：<code class="language-plaintext highlighter-rouge">USER user1:group1</code><tr><td>VOLUME<td>添加文件卷，例如：<code class="language-plaintext highlighter-rouge">VOLUME /myvol</code><tr><td>EXPOSE<td>暴露指定端口，例如：<code class="language-plaintext highlighter-rouge">EXPOSE 80/tcp</code><tr><td>CMD<td>容器的默认命令，例如：<code class="language-plaintext highlighter-rouge">CMD [“echo”, “hello”]</code><tr><td>ENTRYPOINT<td>容器的入口命令，例如：<code class="language-plaintext highlighter-rouge">ENTRYPOINT [“top”, “-b”]</code></table></div><p>以上只是简单介绍，需要用到具体命令时建议还是参考<a href="https://docs.docker.com/engine/reference/builder/#usage">Dockerfile 官方文档</a>。</p><p>这些命令里最难说清楚的就是<code class="language-plaintext highlighter-rouge">CMD</code>和<code class="language-plaintext highlighter-rouge">ENTRYPOINT</code>，如果我是面试官这是必考题。三言两语说不完，我们改日再聊这个话题吧。</p><p>有了 Dockerfile 之后，只要运行<code class="language-plaintext highlighter-rouge">docker image build</code>就可以生成镜像了。</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nb">cd</span> /your-project-dir
docker image build <span class="nt">-t</span> tobyqin/xmind2testlink:1.0.0 <span class="nb">.</span>
</pre></table></code></div></div><p>一般你需要用<code class="language-plaintext highlighter-rouge">-t</code>参数来给你的镜像取个名字和定个版本，别的参数不太重要。打包完之后发布也是手到擒来：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c"># 需要提前在docker仓库注册账号</span>
<span class="nv">$ </span>docker login
<span class="c"># 输入用户名密码</span>
<span class="nv">$ </span>docker push tobyqin/xmind2testlink:1.0.0
The push refers to repository <span class="o">[</span>docker.io/tobyqin/xmind2testlink]
a50ecd8a5d30: Layer already exists
d306e6933e16: Layer already exists
b48eea5f4f04: Layer already exists
6e7c7e6d6e7f: Layer already exists
2aebd096e0e2: Layer already exists
latest: digest: sha256:c06bc4a35073319b8d7e7ef128a7daa8cdb4e766468ffc50f8a61afcf5ef3f46 size: 1367
</pre></table></code></div></div><p>发布成功后你也就成了一个 Docker 社会人了。</p><h2 id="docker-compose"><span class="mr-2">Docker Compose</span><a href="#docker-compose" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Dockerfile 只是打包一个程序或者一种服务，实际上我们的应用会复杂的多，比如有 web 前端，有大后端，有缓存系统，有消息队列，有数据库等等。</p><p>这时候你就需要使用<a href="https://docs.docker.com/compose/overview/">Docker Compose</a>了，它是一个官方提供的用来定义和运行多个容器的工具，你只要写一个配置文件就可以对容器进行编排，看例子。</p><div class="language-yaml highlighter-rouge"><div class="code-header"> <span data-label-text="YAML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed=""><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1"># docker-compose.yml</span>
<span class="na">version</span><span class="pi">:</span> <span class="s2">"</span><span class="s">3"</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">db</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">postgres</span>
  <span class="na">web</span><span class="pi">:</span>
    <span class="na">build</span><span class="pi">:</span> <span class="s">.</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">5000:5000"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">.:/code</span>
      <span class="pi">-</span> <span class="s">logvolume01:/var/log</span>
    <span class="na">links</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">redis</span>
    <span class="na">depends_on</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">db</span>
  <span class="na">redis</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">redis</span>
<span class="na">volumes</span><span class="pi">:</span>
  <span class="na">logvolume01</span><span class="pi">:</span> <span class="pi">{}</span>
</pre></table></code></div></div><p>有了这个配置文件，你只需要运行<code class="language-plaintext highlighter-rouge">docker-compose up</code>就可以轻松管理配置文件里的一系列容器。</p><p>关于 Docker Compose 的介绍不做深入，也不推荐深入，因为这样的容器编排只能满足小企业或者个人开发者的需求，单台主机。真正在企业中我们会用 <a href="https://docs.docker.com/engine/swarm/">Docker Swarm</a> 或者 <a href="https://kubernetes.io/">Kubernets</a>。</p><h2 id="docker-swarm-和-k8s"><span class="mr-2">Docker Swarm 和 K8S</span><a href="#docker-swarm-和-k8s" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>Swarm 是 Docker 官方提供的一款集群管理工具，其主要作用是把若干台 Docker 主机抽象为一个整体，并且通过一个入口统一管理这些 Docker 主机上的各种 Docker 资源。</p><p>Kubernets 也叫 k8s，中间刚好是 8 个字母。类似的我们还把 international 缩写成 i11l。Kubernets 是 Google 开源的容器编排引擎，支持大规模容器集群管理，自动化部署，自动伸缩，负载均衡，资源监控等等功能。</p><p>Swarm 和 Kubernetes 其实是一类东西，但是 Google 家的东西更强大也更复杂，企业一般会二选一。</p><p>关于容器编排是另外一个话题（很大的），本期内容完。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/tech/'>Tech</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/docker/" class="post-tag no-text-decoration" >Docker</a> <a href="/tags/container/" class="post-tag no-text-decoration" >Container</a> <a href="/tags/devops/" class="post-tag no-text-decoration" >DevOps</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"></div><div class="share-wrapper"> <span class="share-label text-muted mr-1"></span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Docker一篇通 - Practice&url=https%3A%2F%2Ftobyqin.cn%2Fposts%2F2019-04-20%2Fdocker-in-one-day%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Docker一篇通 - Practice&u=https%3A%2F%2Ftobyqin.cn%2Fposts%2F2019-04-20%2Fdocker-in-one-day%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Ftobyqin.cn%2Fposts%2F2019-04-20%2Fdocker-in-one-day%2F" data-toggle="tooltip" data-placement="top" title="Linkedin" target="_blank" rel="noopener" aria-label="Linkedin"> <i class="fa-fw fab fa-linkedin"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="" data-title-succeed=""> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading"></div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/2023-01-28/devops-survey-2022/">软件研发体验调查报告 2022</a><li><a href="/posts/2022-12-28/goodbye-2022/">2022年，再见</a><li><a href="/posts/2019-06-25/various-schemes-for-forwarding-short-messages/">转发短信的各种方案</a><li><a href="/posts/2022-09-04/delegating/">如何有效授权</a><li><a href="/posts/2022-07-26/eat-the-frog/">吃掉那只青蛙</a></ul></div><div id="access-tags"><div class="panel-heading"></div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/tips/">tips</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/book/">book</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/life/">Life</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/flask/">flask</a> <a class="post-tag" href="/tags/python/">Python</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2"></div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4 mt-5"><div id="related-posts" class="mb-2 mb-sm-4"><h3 class="pt-2 mb-4 ml-1" data-toc-skip></h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/2020-01-01/thanks-we-are-busy/"><div class="card-body"> <em class="small" data-ts="1577808000" data-df="DD/MM/YYYY" > 01/01/2020 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>谢谢，我们很忙</h3><div class="text-muted small"><p> 新的一年开始了， 不要为了忙碌而忙碌。 在忙碌中找问题， 多用脑子，避免老年痴呆。</p></div></div></a></div><div class="card"> <a href="/posts/2019-01-29/about-devops-we-may-not-be-talking-about-the-same-thing/"><div class="card-body"> <em class="small" data-ts="1548691200" data-df="DD/MM/YYYY" > 29/01/2019 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>关于 DevOps ，咱们聊的可能不是一回事</h3><div class="text-muted small"><p> 原文： https://www.jianshu.com/p/645bb1283a77 在过去的三年中，我作为 DevOps 的咨询师参与了很多企业的 DevOps 转型咨询以及技术实施，也在不同的社区活动中分享了自己在 DevOps 上的实践、理解和观点。 随着 DevOps 的盛行，我在很多场合和越来越多的人聊起 DevOps。也在不同的渠道听到了很多人在讲 DevOps。...</p></div></div></a></div><div class="card"> <a href="/posts/2019-02-26/priciple-to-deliver-software/"><div class="card-body"> <em class="small" data-ts="1551110400" data-df="DD/MM/YYYY" > 26/02/2019 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>软件交付的原则</h3><div class="text-muted small"><p> 《持续交付-发布可靠软件的系统方法》，部分读书笔记。 为软件发布创建一个可重复且可靠的过程 让软件发布成为一件容易的事情，这是在你开始写一个软件开始前就要想办法达到的目标。只要软件发布简单到点击一个按钮甚至不需要点击按钮就能发布，你才会有动力去持续完善这个软件。 所以一般我在开始开发一个软件时就会考虑它的部署过程，会用到哪些资源，如果更新版本等等问题。 将几乎所有事情都自动化 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/2019-03-27/shift-test-to-left/" class="btn btn-outline-primary" prompt=""><p>测试左移和开发赋能</p></a> <a href="/posts/2019-04-27/life-peom/" class="btn btn-outline-primary" prompt=""><p>山村咏怀</p></a></div><script type="text/javascript"> $(function () { const origin = "https://giscus.app"; const iframe = "iframe.giscus-frame"; const lightTheme = "light"; const darkTheme = "dark_dimmed"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } let giscusAttributes = { "src": "https://giscus.app/client.js", "data-repo": "tobyqin/tobyqin.github.io", "data-repo-id": "R_kgDOHs0WtQ", "data-category": "Comments", "data-category-id": "DIC_kwDOHs0Wtc4CQYoq", "data-mapping": "pathname", "data-reactions-enabled": "1", "data-emit-metadata": "0", "data-theme": initTheme, "data-input-position": "bottom", "data-lang": "", "crossorigin": "anonymous", "async": "" }; let giscusScript = document.createElement("script"); Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value)); document.getElementById("tail-wrapper").appendChild(giscusScript); addEventListener("message", (event) => { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; const theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); const message = { setConfig: { theme: theme } }; const giscus = document.querySelector(iframe).contentWindow; giscus.postMessage({ giscus: message }, origin); } }); }); </script></div></div></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading"></div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/python/">python</a> <a class="post-tag" href="/tags/tips/">tips</a> <a class="post-tag" href="/tags/linux/">Linux</a> <a class="post-tag" href="/tags/book/">book</a> <a class="post-tag" href="/tags/shell/">shell</a> <a class="post-tag" href="/tags/devops/">DevOps</a> <a class="post-tag" href="/tags/life/">Life</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/flask/">flask</a> <a class="post-tag" href="/tags/python/">Python</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><footer><div class="container pl-lg-4 pr-lg-4"><div class="d-flex justify-content-between align-items-center text-muted ml-md-3 mr-md-3"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/tobyqin">Toby Qin</a>.</p></div><div class="footer-right"><p class="mb-0">Using the <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> theme <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a>.</p></div></div></div></footer><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5"></p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lazysizes@5.3.2/lazysizes.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/cn.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/unregister.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-QDMM6HFTDF"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-QDMM6HFTDF'); }); </script>
